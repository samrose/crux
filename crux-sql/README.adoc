= crux-sql

SQL adapter for Crux, built on top of https://calcite.apache.org/[Apache Calcite].

== Setup

`crux-sql` runs in-process as part of the Crux node as a Crux module.

First, add the `crux-sql` dependency to your project:

[source,clojure]
----
[juxt/crux-sql "RELEASE"]]
----

Then add the calcite module to your topology:

[source,clojure]
----
{:crux.node/topology ['crux.kafka/topology 'crux.calcite/module]}
----

== Table Definitions

To define a table, transact a document into Crux:

``` clojure
{:crux.db/id :crux.sql.schema/person
 :crux.sql.table/name "person"
 :crux.sql.table/query '{:find [id name homeworld]
                         :where [[id :name name]
                                 [id :homeworld homeworld]]}
 :crux.sql.table/columns '{id :keyword name :varchar homeworld :varchar}}
```

A SQL table is a schema that maps Crux attributes to SQL table
columns. Any document in Crux that matches the `crux.sql.table/query`
in the schema document is eligible to be returned via the SQL query.

For example with the following Crux transaction operation:

[source,clojure]
----
[:crux.tx/put {:crux.db/id :ivan :name "Ivan" :homeworld "Earth"}]
----

Get a connection and query as such:

[source,clojure]
----
(require '[crux.calcite])

(defn query [node q]
  (with-open [conn (crux.calcite/jdbc-connection node)]
    (let [stmt (.createStatement conn)]
      (->> q (.executeQuery stmt) resultset-seq))))
----

So that:

[source,clojure]
----
(query "SELECT PERSON.NAME FROM PERSON")
----

Returns:

[source,clojure]
----
[{:name "Ivan"}]
----

Note that using JDBC PreparedStatements for queries will be
significantly faster.

== Connecting

If you want to connect in-process, you can do so with the above method
of using `crux.calcite/jdbc-connection` to establish a
`java.sql.Connection`.

You can also use https://calcite.apache.org/avatica/[Apache Avatica]
to connect on-the-wire. Add to the
https://mvnrepository.com/artifact/org.apache.calcite.avatica/avatica-core[Avatica
SQL driver] to your project and use the connection string:

[source,properties]
----
jdbc:avatica:remote:url=http://<server-hostname>:1501;serialization=protobuf
----

`server-hostname` is the hostname of the Crux node.

The port by default is `1501` but you can swap it out by configuring
the `:crux.calcite/port` Crux configuration property, i.e.:

[source,clojure]
----
{:crux.node/topology ['crux.kafka/topology 'crux.calcite/module]
 :crux.calcite/port 1502
...}
----

You can then connect using the Avatica JDBC driver, for example:

[source,clojure]
----
(java.sql.DriverManager/getConnection "jdbc:avatica:remote:url=http://localhost:1501;serialization=protobuf")
----

To connect via the https://github.com/julianhyde/sqlline[SQLLine] CLI tool,
install https://get-coursier.io/docs/cli-installation[Coursier] and run:
[source,bash]
----
coursier launch sqlline:sqlline:1.9.0 org.apache.calcite.avatica:avatica-core:1.16.0 -M sqlline.SqlLine -- -n crux -p crux -u "jdbc:avatica:remote:url=http://localhost:1501;serialization=protobuf" -d org.apache.calcite.avatica.remote.Driver
----

== Column Types

We support a subset of https://docs.oracle.com/javase/8/docs/api/java/sql/Types.html[`java.sql.Types`]:

* `:bigint`
* `:boolean`
* `:double`
* `:decimal
* `:float`
* `:timestamp`
* `:varchar`
* `:keyword`

Note that `bigint` maps to `Long`.

Keyword value are returned as Strings in results. If you need to
filter against a keyword column, then you can use the `KEYWORD` SQL
function, for example:

[source,clojure]
----
SELECT ID,NAME FROM PERSON WHERE ID = KEYWORD('human/ivan')
----

== Column Names

SQL table column names are mapped from the symbols used by the
`:crux.sql.table/query` query backing the table and referred to by
`:crux.sql.table/columns`.

Note that in the case where symbols are prefixed with `?`, then `?` is
stripped for the SQL column name.

== Current Limitations

We support a range of calculations (ceil, lower, upper, concat), but
we do not support all. A notable exception is `cast`.
